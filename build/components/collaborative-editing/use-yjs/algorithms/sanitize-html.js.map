{"version":3,"file":"sanitize-html.js","names":["sanitizeHTML","html","document","implementation","createHTMLDocument","body","innerHTML","elements","getElementsByTagName","elementIndex","length","found","element","tagName","remove","attributeIndex","attributes","key","name","startsWith","removeAttribute"],"sources":["../../../../../src/components/collaborative-editing/use-yjs/algorithms/sanitize-html.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { remove } from '@wordpress/dom';\n\n// TODO: Unsolved problem\n// The limitation in our sanitization strategy is that it does not match the\n// server-side wp_kses rules, which should be considered the canonical config\n// of how unsafe the site owner is willing to be. On sites that do allow script tags,\n// this crude sanitization strategy could wipe out those tags if a peer joined\n// and re-saved their sanitized content.\n//\n// The ideal solution would be for block authors to make sure that any arbitrary code\n// is run through wp_kses before executing.\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * Slightly modified version of wp.dom.safeHTML() that only alters the\n * HTML if it actually finds nodes/attributes to remove. This is so we can leave\n * invalid HTML intact, for example if a user is still in the middle of typing the HTML string.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function sanitizeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\tlet found = 0;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tfound++;\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\tfound++;\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? body.innerHTML : html;\n}\n"],"mappings":";;;;;;AAGA;AAHA;AACA;AACA;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACe,SAASA,YAAY,CAAEC,IAAI,EAAG;EAC5C,4BAAiBC,QAAQ,CAACC,cAAc,CAACC,kBAAkB,CAAE,EAAE,CAAE;IAAzDC,IAAI,yBAAJA,IAAI;EACZA,IAAI,CAACC,SAAS,GAAGL,IAAI;EACrB,IAAMM,QAAQ,GAAGF,IAAI,CAACG,oBAAoB,CAAE,GAAG,CAAE;EACjD,IAAIC,YAAY,GAAGF,QAAQ,CAACG,MAAM;EAClC,IAAIC,KAAK,GAAG,CAAC;EAEb,OAAQF,YAAY,EAAE,EAAG;IACxB,IAAMG,OAAO,GAAGL,QAAQ,CAAEE,YAAY,CAAE;IAExC,IAAKG,OAAO,CAACC,OAAO,KAAK,QAAQ,EAAG;MACnCF,KAAK,EAAE;MACP,IAAAG,WAAM,EAAEF,OAAO,CAAE;IAClB,CAAC,MAAM;MACN,IAAIG,cAAc,GAAGH,OAAO,CAACI,UAAU,CAACN,MAAM;MAE9C,OAAQK,cAAc,EAAE,EAAG;QAC1B,IAAcE,GAAG,GAAKL,OAAO,CAACI,UAAU,CAAED,cAAc,CAAE,CAAlDG,IAAI;QAEZ,IAAKD,GAAG,CAACE,UAAU,CAAE,IAAI,CAAE,EAAG;UAC7BR,KAAK,EAAE;UACPC,OAAO,CAACQ,eAAe,CAAEH,GAAG,CAAE;QAC/B;MACD;IACD;EACD;EAEA,OAAON,KAAK,GAAGN,IAAI,CAACC,SAAS,GAAGL,IAAI;AACrC"}