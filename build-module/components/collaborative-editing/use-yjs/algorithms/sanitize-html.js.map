{"version":3,"file":"sanitize-html.js","names":["remove","sanitizeHTML","html","body","document","implementation","createHTMLDocument","innerHTML","elements","getElementsByTagName","elementIndex","length","found","element","tagName","attributeIndex","attributes","name","key","startsWith","removeAttribute"],"sources":["../../../../../src/components/collaborative-editing/use-yjs/algorithms/sanitize-html.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { remove } from '@wordpress/dom';\n\n// TODO: Unsolved problem\n// The limitation in our sanitization strategy is that it does not match the\n// server-side wp_kses rules, which should be considered the canonical config\n// of how unsafe the site owner is willing to be. On sites that do allow script tags,\n// this crude sanitization strategy could wipe out those tags if a peer joined\n// and re-saved their sanitized content.\n//\n// The ideal solution would be for block authors to make sure that any arbitrary code\n// is run through wp_kses before executing.\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * Slightly modified version of wp.dom.safeHTML() that only alters the\n * HTML if it actually finds nodes/attributes to remove. This is so we can leave\n * invalid HTML intact, for example if a user is still in the middle of typing the HTML string.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function sanitizeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\tlet found = 0;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tfound++;\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\tfound++;\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? body.innerHTML : html;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAT,QAAuB,gBAAvB,C,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AACA,eAAe,SAASC,YAAT,CAAuBC,IAAvB,EAA8B;EAC5C,MAAM;IAAEC;EAAF,IAAWC,QAAQ,CAACC,cAAT,CAAwBC,kBAAxB,CAA4C,EAA5C,CAAjB;EACAH,IAAI,CAACI,SAAL,GAAiBL,IAAjB;EACA,MAAMM,QAAQ,GAAGL,IAAI,CAACM,oBAAL,CAA2B,GAA3B,CAAjB;EACA,IAAIC,YAAY,GAAGF,QAAQ,CAACG,MAA5B;EACA,IAAIC,KAAK,GAAG,CAAZ;;EAEA,OAAQF,YAAY,EAApB,EAAyB;IACxB,MAAMG,OAAO,GAAGL,QAAQ,CAAEE,YAAF,CAAxB;;IAEA,IAAKG,OAAO,CAACC,OAAR,KAAoB,QAAzB,EAAoC;MACnCF,KAAK;MACLZ,MAAM,CAAEa,OAAF,CAAN;IACA,CAHD,MAGO;MACN,IAAIE,cAAc,GAAGF,OAAO,CAACG,UAAR,CAAmBL,MAAxC;;MAEA,OAAQI,cAAc,EAAtB,EAA2B;QAC1B,MAAM;UAAEE,IAAI,EAAEC;QAAR,IAAgBL,OAAO,CAACG,UAAR,CAAoBD,cAApB,CAAtB;;QAEA,IAAKG,GAAG,CAACC,UAAJ,CAAgB,IAAhB,CAAL,EAA8B;UAC7BP,KAAK;UACLC,OAAO,CAACO,eAAR,CAAyBF,GAAzB;QACA;MACD;IACD;EACD;;EAED,OAAON,KAAK,GAAGT,IAAI,CAACI,SAAR,GAAoBL,IAAhC;AACA"}