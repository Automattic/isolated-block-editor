{"version":3,"file":"sanitize-html.js","names":["remove","sanitizeHTML","html","body","document","implementation","createHTMLDocument","innerHTML","elements","getElementsByTagName","elementIndex","length","found","element","tagName","attributeIndex","attributes","name","key","startsWith","removeAttribute"],"sources":["../../../../../src/components/collaborative-editing/use-yjs/algorithms/sanitize-html.js"],"sourcesContent":["/**\n * WordPress dependencies\n */\nimport { remove } from '@wordpress/dom';\n\n// TODO: Unsolved problem\n// The limitation in our sanitization strategy is that it does not match the\n// server-side wp_kses rules, which should be considered the canonical config\n// of how unsafe the site owner is willing to be. On sites that do allow script tags,\n// this crude sanitization strategy could wipe out those tags if a peer joined\n// and re-saved their sanitized content.\n//\n// The ideal solution would be for block authors to make sure that any arbitrary code\n// is run through wp_kses before executing.\n\n/**\n * Strips scripts and on* attributes from HTML.\n *\n * Slightly modified version of wp.dom.safeHTML() that only alters the\n * HTML if it actually finds nodes/attributes to remove. This is so we can leave\n * invalid HTML intact, for example if a user is still in the middle of typing the HTML string.\n *\n * @param {string} html HTML to sanitize.\n *\n * @return {string} The sanitized HTML.\n */\nexport default function sanitizeHTML( html ) {\n\tconst { body } = document.implementation.createHTMLDocument( '' );\n\tbody.innerHTML = html;\n\tconst elements = body.getElementsByTagName( '*' );\n\tlet elementIndex = elements.length;\n\tlet found = 0;\n\n\twhile ( elementIndex-- ) {\n\t\tconst element = elements[ elementIndex ];\n\n\t\tif ( element.tagName === 'SCRIPT' ) {\n\t\t\tfound++;\n\t\t\tremove( element );\n\t\t} else {\n\t\t\tlet attributeIndex = element.attributes.length;\n\n\t\t\twhile ( attributeIndex-- ) {\n\t\t\t\tconst { name: key } = element.attributes[ attributeIndex ];\n\n\t\t\t\tif ( key.startsWith( 'on' ) ) {\n\t\t\t\t\tfound++;\n\t\t\t\t\telement.removeAttribute( key );\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\treturn found ? body.innerHTML : html;\n}\n"],"mappings":"AAAA;AACA;AACA;AACA,SAASA,MAAM,QAAQ,gBAAgB;;AAEvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,SAASC,YAAY,CAAEC,IAAI,EAAG;EAC5C,MAAM;IAAEC;EAAK,CAAC,GAAGC,QAAQ,CAACC,cAAc,CAACC,kBAAkB,CAAE,EAAE,CAAE;EACjEH,IAAI,CAACI,SAAS,GAAGL,IAAI;EACrB,MAAMM,QAAQ,GAAGL,IAAI,CAACM,oBAAoB,CAAE,GAAG,CAAE;EACjD,IAAIC,YAAY,GAAGF,QAAQ,CAACG,MAAM;EAClC,IAAIC,KAAK,GAAG,CAAC;EAEb,OAAQF,YAAY,EAAE,EAAG;IACxB,MAAMG,OAAO,GAAGL,QAAQ,CAAEE,YAAY,CAAE;IAExC,IAAKG,OAAO,CAACC,OAAO,KAAK,QAAQ,EAAG;MACnCF,KAAK,EAAE;MACPZ,MAAM,CAAEa,OAAO,CAAE;IAClB,CAAC,MAAM;MACN,IAAIE,cAAc,GAAGF,OAAO,CAACG,UAAU,CAACL,MAAM;MAE9C,OAAQI,cAAc,EAAE,EAAG;QAC1B,MAAM;UAAEE,IAAI,EAAEC;QAAI,CAAC,GAAGL,OAAO,CAACG,UAAU,CAAED,cAAc,CAAE;QAE1D,IAAKG,GAAG,CAACC,UAAU,CAAE,IAAI,CAAE,EAAG;UAC7BP,KAAK,EAAE;UACPC,OAAO,CAACO,eAAe,CAAEF,GAAG,CAAE;QAC/B;MACD;IACD;EACD;EAEA,OAAON,KAAK,GAAGT,IAAI,CAACI,SAAS,GAAGL,IAAI;AACrC"}